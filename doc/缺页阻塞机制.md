在Linux内核中，I/O阻塞涉及几个关键结构和机制，特别是在缺页处理过程中。当进程尝试读取不在内存中的页面时，阻塞和等待机制主要通过以下方式实现：

## 页面I/O阻塞的核心机制

1. **页面状态标志（PG_locked等）**：
   - 每个页描述符(struct page)包含状态标志位
   - PG_locked标志表示页面当前正在进行I/O操作
   - 其他进程看到这个标志时，会知道页面正在加载

2. **等待队列（wait_queue_head_t）**：
   - 页描述符中包含等待队列头
   - 当进程发现页面正在加载(PG_locked置位)时，会将自己添加到这个等待队列

3. **bio结构**：
   - 代表块I/O请求的基本单位
   - 包含请求完成时要调用的回调函数
   - 管理待处理I/O的状态

## 缺页过程中的阻塞机制

当发生缺页时，处理流程大致如下：

1. **查找阶段**：
   - 通过address_space的基数树查找是否有对应的页面
   - 如果找到且页面已锁定(PG_locked)，表明另一进程正在加载该页面

2. **等待现有I/O**：
   - 如果页面存在但被锁定，当前进程调用`wait_on_page_locked()`
   - 这个函数将进程添加到页面的等待队列，并将进程状态设置为TASK_UNINTERRUPTIBLE
   - 进程被调度出CPU，进入睡眠状态

3. **发起新I/O**：
   - 如果页面不存在，分配新页面并锁定(PG_locked)
   - 通过address_space的readpage()操作函数发起I/O请求
   - 此操作最终创建bio结构并提交到块I/O层

4. **I/O完成时的唤醒**：
   - 当I/O操作完成时，中断处理程序触发回调
   - 回调函数清除页面的PG_locked标志
   - 调用`wake_up_page()`唤醒等待队列中的所有进程

## 具体对象和结构

1. **struct page**：
   - 包含PG_locked等标志位
   - 包含指向等待队列的指针（wait_queue_head_t）

2. **wait_queue_head_t**：
   - 维护等待特定事件（如页面解锁）的进程列表
   - 由wake_up_*函数族激活

3. **struct bio**：
   - 表示向块设备发出的I/O请求
   - 包含完成回调，在I/O完成时触发唤醒机制

4. **buffer_head**（传统机制）：
   - 在某些文件系统中仍用于管理块设备I/O
   - 也包含完成回调和状态标志

核心函数包括：
- `lock_page()`/`unlock_page()`：锁定/解锁页面
- `wait_on_page_locked()`：等待页面解锁
- `wake_up_page()`：唤醒等待页面的进程
- `add_wait_queue()`/`remove_wait_queue()`：管理等待队列

这套机制确保了多个进程可以安全地协调对同一页面的访问，避免重复I/O请求，并在I/O完成时高效地唤醒等待进程。